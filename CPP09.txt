| Container                 | Type       | ComplexitÃ© (accÃ¨s / insertion)                                | ParticularitÃ©               | Cas dâ€™usage                                   | Exo CPP09              |
| ------------------------- | ---------- | ------------------------------------------------------------- | --------------------------- | --------------------------------------------- | ---------------------- |
| **`std::vector`**         | SÃ©quentiel | AccÃ¨s index `O(1)` / Insert fin `O(1)` / Insert milieu `O(n)` | Tableau dynamique           | Stocker suite dâ€™Ã©lÃ©ments, accÃ¨s rapide        | **Ex02** (tri)         |
| **`std::deque`**          | SÃ©quentiel | AccÃ¨s index `O(1)` / Insert dÃ©but & fin `O(1)`                | Tableau double-entrÃ©e       | File ou pile flexible, comparatif avec vector | **Ex02** (tri)         |
| **`std::list`**           | SÃ©quentiel | AccÃ¨s `O(n)` / Insert `O(1)` (oÃ¹ tu as lâ€™itÃ©rateur)           | Liste chaÃ®nÃ©e               | Beaucoup dâ€™insertions/suppressions au milieu  | -                      |
| **`std::map`**            | Associatif | Recherche `O(log n)` / Insert `O(log n)`                      | ClÃ©s **triÃ©es**             | Associer clÃ©â†’valeur avec ordre                | **Ex00** (dateâ†’valeur) |
| **`std::multimap`**       | Associatif | Idem `map`                                                    | ClÃ©s en double autorisÃ©es   | Cas rares                                     | -                      |
| **`std::set`**            | Associatif | Recherche `O(log n)` / Insert `O(log n)`                      | Ensemble triÃ©, sans doublon | VÃ©rifier existence                            | -                      |
| **`std::unordered_map`**  | Hash       | Recherche `O(1)` en moyenne                                   | ClÃ©s **non triÃ©es**         | Associer clÃ©â†’valeur rapidement sans ordre     | -                      |
| **`std::unordered_set`**  | Hash       | Recherche `O(1)`                                              | Ensemble non triÃ©           | VÃ©rifier existence trÃ¨s vite                  | -                      |
| **`std::stack`**          | Adaptateur | `push/pop/top` en `O(1)`                                      | BasÃ© sur deque              | Pile LIFO                                     | **Ex01**               |
| **`std::queue`**          | Adaptateur | `push/pop/front/back` en `O(1)`                               | BasÃ© sur deque              | File FIFO                                     | -                      |
| **`std::priority_queue`** | Adaptateur | `push/pop` en `O(log n)`                                      | Max-heap                    | Extraire lâ€™Ã©lÃ©ment max                        | -                      |


ğŸ—‚ï¸ Fiche MÃ©mo Containers STL
SÃ©quentiels

std::vector â†’ Tableau dynamique, accÃ¨s index rapide, idÃ©al pour stocker et parcourir.

std::deque â†’ Tableau double-entrÃ©e, insertions rapides au dÃ©but et Ã  la fin.

std::list â†’ Liste chaÃ®nÃ©e, insertions/suppressions rapides partout, mais accÃ¨s lent.

Associatifs (triÃ©s)

std::map â†’ Associe clÃ©s uniques triÃ©es Ã  des valeurs (clÃ© â†’ valeur).

std::multimap â†’ Comme map, mais accepte des clÃ©s dupliquÃ©es.

std::set â†’ Ensemble triÃ© de valeurs uniques.

std::multiset â†’ Comme set, mais accepte les doublons.

Associatifs (non ordonnÃ©s â†’ hash)

std::unordered_map â†’ Associe clÃ©s uniques Ã  valeurs, accÃ¨s ultra-rapide, pas dâ€™ordre.

std::unordered_set â†’ Ensemble non triÃ© de valeurs uniques, accÃ¨s ultra-rapide.

Adaptateurs

std::stack â†’ Pile LIFO (dernier entrÃ©, premier sorti).

std::queue â†’ File FIFO (premier entrÃ©, premier sorti).

std::priority_queue â†’ File Ã  prioritÃ© (toujours lâ€™Ã©lÃ©ment max/min en tÃªte).

Pour le premier exercice, on utilisera std::map.
Ex00 â€“ BitcoinExchange
Objectif : associer une date Ã  une valeur.
ğŸ‘‰ Container adaptÃ© : std::map<std::string, float> (dates triÃ©es).

Pour le deuxiÃ¨me exercice, on utilisera std::stack
Ex01 â€“ RPN (Reverse Polish Notation)
Objectif : calculer une expression polonaise inversÃ©e.
ğŸ‘‰ Container adaptÃ© : std::stack<int>.
Car on dÃ©pile les opÃ©randes dÃ¨s quâ€™on rencontre un opÃ©rateur.

Pour le troisiÃ¨me exercice, on utilisera std::vector et std::deque
Ex02 â€“ PmergeMe
Objectif : implÃ©menter un tri fusion (merge-insertion sort).
ğŸ‘‰ Containers adaptÃ©s : std::vector<int> et std::deque<int>.

Ex02 :

